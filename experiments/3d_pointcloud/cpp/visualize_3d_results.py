#!/usr/bin/env python3
"""Visualize 3D GNG test results from C++ output.

Reads CSV files generated by C++ tests and creates:
- GIF animation with 3D rotation
- PNG with multi-view (3D perspective + 2D side view)

Usage:
    python visualize_3d_results.py <input_dir> [options]

Examples:
    python visualize_3d_results.py gng_floor_wall_output
    python visualize_3d_results.py gngdt_floor_wall_output --algorithm gngdt
    python visualize_3d_results.py gngdt_robot_floor_wall_output --algorithm gngdt_robot
"""

import argparse
from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
from PIL import Image


def load_csv(path: str, skip_header: bool = True) -> np.ndarray:
    """Load CSV file as numpy array."""
    return np.loadtxt(path, delimiter=",", skiprows=1 if skip_header else 0)


def load_edges(path: str) -> list[tuple[int, int]]:
    """Load edges from CSV file."""
    data = load_csv(path)
    if len(data.shape) == 1:
        if len(data) == 0:
            return []
        data = data.reshape(1, -1)
    return [(int(row[0]), int(row[1])) for row in data]


def load_metadata(path: str) -> dict[str, str]:
    """Load metadata CSV as dictionary."""
    metadata = {}
    with open(path) as f:
        next(f)  # Skip header
        for line in f:
            key, value = line.strip().split(",", 1)
            metadata[key] = value
    return metadata


def draw_floor_wall_surfaces(ax, floor_size: float = 0.8, wall_height: float = 0.6) -> None:
    """Draw semi-transparent floor and wall surfaces."""
    offset = (1.0 - floor_size) / 2

    # Floor surface (XZ plane at y=0)
    floor_x = np.array([[offset, offset + floor_size], [offset, offset + floor_size]])
    floor_z = np.array([[offset, offset], [offset + floor_size, offset + floor_size]])
    floor_y = np.zeros_like(floor_x)
    ax.plot_surface(floor_x, floor_y, floor_z, alpha=0.2, color="lightblue")

    # Wall surface (XY plane at z=offset)
    wall_x = np.array([[offset, offset + floor_size], [offset, offset + floor_size]])
    wall_y = np.array([[0, 0], [wall_height, wall_height]])
    wall_z = np.full_like(wall_x, offset)
    ax.plot_surface(wall_x, wall_y, wall_z, alpha=0.2, color="lightgreen")


def create_frame_gng(
    ax,
    samples: np.ndarray,
    nodes: np.ndarray,
    edges: list[tuple[int, int]],
    iteration: int,
    algorithm: str,
    azim: float = 120,
    elev: float = 25,
) -> None:
    """Create a single frame for basic GNG visualization."""
    ax.clear()

    draw_floor_wall_surfaces(ax)

    # Plot samples
    ax.scatter(
        samples[:, 0], samples[:, 1], samples[:, 2],
        c="skyblue", s=2, alpha=0.2, label="Data"
    )

    # Plot edges
    for i, j in edges:
        ax.plot(
            [nodes[i, 0], nodes[j, 0]],
            [nodes[i, 1], nodes[j, 1]],
            [nodes[i, 2], nodes[j, 2]],
            "r-", linewidth=0.8, alpha=0.5
        )

    # Plot nodes
    ax.scatter(
        nodes[:, 0], nodes[:, 1], nodes[:, 2],
        c="red", s=30, zorder=5, label="Nodes"
    )

    ax.set_xlim(0, 1)
    ax.set_ylim(0, 1)
    ax.set_zlim(0, 1)
    ax.set_xlabel("X")
    ax.set_ylabel("Y (depth)")
    ax.set_zlabel("Z (height)")
    ax.set_title(f"{algorithm} Floor+Wall - Iter {iteration}\n({len(nodes)} nodes, {len(edges)} edges)")
    ax.legend(loc="upper right")
    ax.view_init(elev=elev, azim=azim)


def create_frame_gngdt(
    ax,
    samples: np.ndarray,
    nodes: np.ndarray,
    pos_edges: list[tuple[int, int]],
    normal_edges: list[tuple[int, int]],
    iteration: int,
    azim: float = 120,
    elev: float = 25,
) -> None:
    """Create a single frame for GNG-DT visualization."""
    ax.clear()

    draw_floor_wall_surfaces(ax)

    # Plot samples
    ax.scatter(
        samples[:, 0], samples[:, 1], samples[:, 2],
        c="skyblue", s=2, alpha=0.2, label="Data"
    )

    # Plot position edges (red)
    for i, j in pos_edges:
        ax.plot(
            [nodes[i, 0], nodes[j, 0]],
            [nodes[i, 1], nodes[j, 1]],
            [nodes[i, 2], nodes[j, 2]],
            "r-", linewidth=0.8, alpha=0.5
        )

    # Plot normal edges (blue)
    for i, j in normal_edges:
        ax.plot(
            [nodes[i, 0], nodes[j, 0]],
            [nodes[i, 1], nodes[j, 1]],
            [nodes[i, 2], nodes[j, 2]],
            "b-", linewidth=1.2, alpha=0.7
        )

    # Plot nodes
    ax.scatter(
        nodes[:, 0], nodes[:, 1], nodes[:, 2],
        c="red", s=30, zorder=5, label="Nodes"
    )

    ax.set_xlim(0, 1)
    ax.set_ylim(0, 1)
    ax.set_zlim(0, 1)
    ax.set_xlabel("X")
    ax.set_ylabel("Y (depth)")
    ax.set_zlabel("Z (height)")
    ax.set_title(
        f"GNG-DT Floor+Wall - Iter {iteration}\n"
        f"({len(nodes)} nodes, {len(pos_edges)} pos-edges, {len(normal_edges)} normal-edges)"
    )
    ax.legend(loc="upper right")
    ax.view_init(elev=elev, azim=azim)


def create_frame_gngdt_robot(
    ax,
    samples: np.ndarray,
    nodes: np.ndarray,
    pos_edges: list[tuple[int, int]],
    traversability: np.ndarray,
    contour: np.ndarray,
    iteration: int,
    azim: float = 120,
    elev: float = 25,
) -> None:
    """Create a single frame for GNG-DT Robot visualization."""
    ax.clear()

    draw_floor_wall_surfaces(ax)

    # Plot samples
    ax.scatter(
        samples[:, 0], samples[:, 1], samples[:, 2],
        c="skyblue", s=2, alpha=0.2, label="Data"
    )

    # Plot edges
    for i, j in pos_edges:
        ax.plot(
            [nodes[i, 0], nodes[j, 0]],
            [nodes[i, 1], nodes[j, 1]],
            [nodes[i, 2], nodes[j, 2]],
            "gray", linewidth=0.5, alpha=0.3
        )

    # Color nodes by traversability and contour
    # Green: traversable, Red: non-traversable, Orange: contour
    colors = []
    for t, c in zip(traversability, contour):
        if c == 1:
            colors.append("orange")
        elif t == 1:
            colors.append("green")
        else:
            colors.append("red")

    ax.scatter(
        nodes[:, 0], nodes[:, 1], nodes[:, 2],
        c=colors, s=40, zorder=5
    )

    n_traversable = int(np.sum(traversability))
    n_contour = int(np.sum(contour))

    ax.set_xlim(0, 1)
    ax.set_ylim(0, 1)
    ax.set_zlim(0, 1)
    ax.set_xlabel("X")
    ax.set_ylabel("Y (depth)")
    ax.set_zlabel("Z (height)")
    ax.set_title(
        f"GNG-DT Robot - Iter {iteration}\n"
        f"({len(nodes)} nodes, {n_traversable} traversable, {n_contour} contour)"
    )
    ax.view_init(elev=elev, azim=azim)


def visualize_gng(input_dir: str, output_gif: str, output_png: str, algorithm: str = "GNG") -> None:
    """Visualize basic GNG results."""
    input_path = Path(input_dir)

    # Load data
    samples = load_csv(input_path / "samples.csv")
    frames_df = load_csv(input_path / "frames.csv")
    iterations = [int(i) for i in frames_df.flatten()]

    # Create GIF frames
    fig = plt.figure(figsize=(10, 10), facecolor="white")
    ax = fig.add_subplot(111, projection="3d")

    frames = []
    azim_start, azim_end = 120, 180

    for idx, iteration in enumerate(iterations):
        iter_str = f"{iteration:05d}"
        nodes = load_csv(input_path / f"nodes_{iter_str}.csv")
        edges = load_edges(input_path / f"edges_{iter_str}.csv")

        progress = idx / max(1, len(iterations) - 1)
        azim = azim_start + (azim_end - azim_start) * progress

        create_frame_gng(ax, samples, nodes, edges, iteration, algorithm, azim=azim)
        fig.canvas.draw()

        img = Image.frombuffer("RGBA", fig.canvas.get_width_height(), fig.canvas.buffer_rgba())
        frames.append(img.convert("RGB"))

        print(f"Frame {idx + 1}/{len(iterations)}: iter={iteration}, {len(nodes)} nodes")

    plt.close(fig)

    # Save GIF
    if frames:
        frames.extend([frames[-1]] * 10)
        frames[0].save(output_gif, save_all=True, append_images=frames[1:], duration=100, loop=0)
        print(f"Saved GIF: {output_gif}")

    # Create final PNG
    final_nodes = load_csv(input_path / "final_nodes.csv")
    final_edges = load_edges(input_path / "final_edges.csv")

    fig_final = plt.figure(figsize=(14, 7), facecolor="white")

    # Left: 3D view
    ax_3d = fig_final.add_subplot(1, 2, 1, projection="3d")
    draw_floor_wall_surfaces(ax_3d)
    ax_3d.scatter(samples[:, 0], samples[:, 1], samples[:, 2], c="skyblue", s=2, alpha=0.2)
    for i, j in final_edges:
        ax_3d.plot(
            [final_nodes[i, 0], final_nodes[j, 0]],
            [final_nodes[i, 1], final_nodes[j, 1]],
            [final_nodes[i, 2], final_nodes[j, 2]],
            "r-", linewidth=0.8, alpha=0.6
        )
    ax_3d.scatter(final_nodes[:, 0], final_nodes[:, 1], final_nodes[:, 2], c="red", s=30, zorder=5)
    ax_3d.set_xlim(0, 1)
    ax_3d.set_ylim(0, 1)
    ax_3d.set_zlim(0, 1)
    ax_3d.set_xlabel("X")
    ax_3d.set_ylabel("Y")
    ax_3d.set_zlabel("Z")
    ax_3d.set_title(f"3D View ({len(final_edges)} edges)")
    ax_3d.view_init(elev=25, azim=azim_start)

    # Right: 2D side view (YZ)
    ax_2d = fig_final.add_subplot(1, 2, 2)
    ax_2d.scatter(samples[:, 1], samples[:, 2], c="skyblue", s=2, alpha=0.2, label="Data")
    for i, j in final_edges:
        ax_2d.plot(
            [final_nodes[i, 1], final_nodes[j, 1]],
            [final_nodes[i, 2], final_nodes[j, 2]],
            "r-", linewidth=0.5, alpha=0.4
        )
    ax_2d.scatter(final_nodes[:, 1], final_nodes[:, 2], c="red", s=30, zorder=5, label="Nodes")
    ax_2d.set_xlim(1, 0)
    ax_2d.set_ylim(0, 1)
    ax_2d.set_xlabel("Y (depth)")
    ax_2d.set_ylabel("Z (height)")
    ax_2d.set_aspect("equal")
    ax_2d.set_title("Side View (YZ)")
    ax_2d.legend(loc="upper left")

    plt.suptitle(f"{algorithm}: {len(final_nodes)} nodes, {len(final_edges)} edges", fontsize=12)
    plt.tight_layout()
    plt.savefig(output_png, dpi=150, bbox_inches="tight", facecolor="white")
    print(f"Saved PNG: {output_png}")
    plt.close(fig_final)


def visualize_gngdt(input_dir: str, output_gif: str, output_png: str) -> None:
    """Visualize GNG-DT results with multi-topology edges."""
    input_path = Path(input_dir)

    samples = load_csv(input_path / "samples.csv")
    frames_df = load_csv(input_path / "frames.csv")
    iterations = [int(i) for i in frames_df.flatten()]

    fig = plt.figure(figsize=(10, 10), facecolor="white")
    ax = fig.add_subplot(111, projection="3d")

    frames = []
    azim_start, azim_end = 120, 180

    for idx, iteration in enumerate(iterations):
        iter_str = f"{iteration:05d}"
        nodes = load_csv(input_path / f"nodes_{iter_str}.csv")
        pos_edges = load_edges(input_path / f"pos_edges_{iter_str}.csv")
        normal_edges_path = input_path / f"normal_edges_{iter_str}.csv"
        normal_edges = load_edges(normal_edges_path) if normal_edges_path.exists() else []

        progress = idx / max(1, len(iterations) - 1)
        azim = azim_start + (azim_end - azim_start) * progress

        create_frame_gngdt(ax, samples, nodes, pos_edges, normal_edges, iteration, azim=azim)
        fig.canvas.draw()

        img = Image.frombuffer("RGBA", fig.canvas.get_width_height(), fig.canvas.buffer_rgba())
        frames.append(img.convert("RGB"))

        print(f"Frame {idx + 1}/{len(iterations)}: iter={iteration}, {len(nodes)} nodes")

    plt.close(fig)

    if frames:
        frames.extend([frames[-1]] * 10)
        frames[0].save(output_gif, save_all=True, append_images=frames[1:], duration=100, loop=0)
        print(f"Saved GIF: {output_gif}")

    # Final PNG with 3 views
    final_nodes = load_csv(input_path / "final_nodes.csv")
    final_pos_edges = load_edges(input_path / "final_pos_edges.csv")
    final_normal_edges = load_edges(input_path / "final_normal_edges.csv") if (input_path / "final_normal_edges.csv").exists() else []
    final_normals = load_csv(input_path / "final_normals.csv") if (input_path / "final_normals.csv").exists() else None

    fig_final = plt.figure(figsize=(18, 7), facecolor="white")

    # Left: Position edges
    ax_pos = fig_final.add_subplot(1, 3, 1, projection="3d")
    draw_floor_wall_surfaces(ax_pos)
    ax_pos.scatter(samples[:, 0], samples[:, 1], samples[:, 2], c="skyblue", s=2, alpha=0.2)
    for i, j in final_pos_edges:
        ax_pos.plot(
            [final_nodes[i, 0], final_nodes[j, 0]],
            [final_nodes[i, 1], final_nodes[j, 1]],
            [final_nodes[i, 2], final_nodes[j, 2]],
            "r-", linewidth=0.8, alpha=0.6
        )
    ax_pos.scatter(final_nodes[:, 0], final_nodes[:, 1], final_nodes[:, 2], c="red", s=30, zorder=5)
    ax_pos.set_xlim(0, 1)
    ax_pos.set_ylim(0, 1)
    ax_pos.set_zlim(0, 1)
    ax_pos.set_title(f"Position Topology ({len(final_pos_edges)} edges)")
    ax_pos.view_init(elev=25, azim=azim_start)

    # Middle: Normal edges
    ax_norm = fig_final.add_subplot(1, 3, 2, projection="3d")
    draw_floor_wall_surfaces(ax_norm)
    ax_norm.scatter(samples[:, 0], samples[:, 1], samples[:, 2], c="skyblue", s=2, alpha=0.2)
    for i, j in final_normal_edges:
        ax_norm.plot(
            [final_nodes[i, 0], final_nodes[j, 0]],
            [final_nodes[i, 1], final_nodes[j, 1]],
            [final_nodes[i, 2], final_nodes[j, 2]],
            "b-", linewidth=1.0, alpha=0.7
        )
    ax_norm.scatter(final_nodes[:, 0], final_nodes[:, 1], final_nodes[:, 2], c="blue", s=30, zorder=5)
    if final_normals is not None:
        scale = 0.06
        ax_norm.quiver(
            final_nodes[:, 0], final_nodes[:, 1], final_nodes[:, 2],
            final_normals[:, 0] * scale, final_normals[:, 1] * scale, final_normals[:, 2] * scale,
            color="green", alpha=0.8, arrow_length_ratio=0.3
        )
    ax_norm.set_xlim(0, 1)
    ax_norm.set_ylim(0, 1)
    ax_norm.set_zlim(0, 1)
    ax_norm.set_title(f"Normal Topology ({len(final_normal_edges)} edges)")
    ax_norm.view_init(elev=25, azim=azim_start)

    # Right: 2D side view
    ax_2d = fig_final.add_subplot(1, 3, 3)
    ax_2d.scatter(samples[:, 1], samples[:, 2], c="skyblue", s=2, alpha=0.2)
    for i, j in final_pos_edges:
        ax_2d.plot([final_nodes[i, 1], final_nodes[j, 1]], [final_nodes[i, 2], final_nodes[j, 2]],
                   "r-", linewidth=0.5, alpha=0.4)
    for i, j in final_normal_edges:
        ax_2d.plot([final_nodes[i, 1], final_nodes[j, 1]], [final_nodes[i, 2], final_nodes[j, 2]],
                   "b-", linewidth=1.0, alpha=0.7)
    ax_2d.scatter(final_nodes[:, 1], final_nodes[:, 2], c="red", s=30, zorder=5)
    ax_2d.set_xlim(1, 0)
    ax_2d.set_ylim(0, 1)
    ax_2d.set_xlabel("Y (depth)")
    ax_2d.set_ylabel("Z (height)")
    ax_2d.set_aspect("equal")
    ax_2d.set_title("Side View (Red=Position, Blue=Normal)")

    plt.suptitle(
        f"GNG-DT: {len(final_nodes)} nodes | Position: {len(final_pos_edges)} | Normal: {len(final_normal_edges)}",
        fontsize=12
    )
    plt.tight_layout()
    plt.savefig(output_png, dpi=150, bbox_inches="tight", facecolor="white")
    print(f"Saved PNG: {output_png}")
    plt.close(fig_final)


def visualize_gngdt_robot(input_dir: str, output_gif: str, output_png: str) -> None:
    """Visualize GNG-DT Robot results with traversability."""
    input_path = Path(input_dir)

    samples = load_csv(input_path / "samples.csv")
    frames_df = load_csv(input_path / "frames.csv")
    iterations = [int(i) for i in frames_df.flatten()]

    fig = plt.figure(figsize=(10, 10), facecolor="white")
    ax = fig.add_subplot(111, projection="3d")

    frames = []
    azim_start, azim_end = 120, 180

    for idx, iteration in enumerate(iterations):
        iter_str = f"{iteration:05d}"
        nodes = load_csv(input_path / f"nodes_{iter_str}.csv")
        pos_edges = load_edges(input_path / f"pos_edges_{iter_str}.csv")
        traversability = load_csv(input_path / f"traversability_{iter_str}.csv").flatten().astype(int)
        contour = load_csv(input_path / f"contour_{iter_str}.csv").flatten().astype(int)

        progress = idx / max(1, len(iterations) - 1)
        azim = azim_start + (azim_end - azim_start) * progress

        create_frame_gngdt_robot(ax, samples, nodes, pos_edges, traversability, contour, iteration, azim=azim)
        fig.canvas.draw()

        img = Image.frombuffer("RGBA", fig.canvas.get_width_height(), fig.canvas.buffer_rgba())
        frames.append(img.convert("RGB"))

        print(f"Frame {idx + 1}/{len(iterations)}: iter={iteration}, {len(nodes)} nodes")

    plt.close(fig)

    if frames:
        frames.extend([frames[-1]] * 10)
        frames[0].save(output_gif, save_all=True, append_images=frames[1:], duration=100, loop=0)
        print(f"Saved GIF: {output_gif}")

    # Final PNG
    final_nodes = load_csv(input_path / "final_nodes.csv")
    final_pos_edges = load_edges(input_path / "final_pos_edges.csv")
    final_traversability = load_csv(input_path / "final_traversability.csv").flatten().astype(int)
    final_contour = load_csv(input_path / "final_contour.csv").flatten().astype(int)

    colors = []
    for t, c in zip(final_traversability, final_contour):
        if c == 1:
            colors.append("orange")
        elif t == 1:
            colors.append("green")
        else:
            colors.append("red")

    fig_final = plt.figure(figsize=(14, 7), facecolor="white")

    ax_3d = fig_final.add_subplot(1, 2, 1, projection="3d")
    draw_floor_wall_surfaces(ax_3d)
    ax_3d.scatter(samples[:, 0], samples[:, 1], samples[:, 2], c="skyblue", s=2, alpha=0.2)
    for i, j in final_pos_edges:
        ax_3d.plot(
            [final_nodes[i, 0], final_nodes[j, 0]],
            [final_nodes[i, 1], final_nodes[j, 1]],
            [final_nodes[i, 2], final_nodes[j, 2]],
            "gray", linewidth=0.5, alpha=0.3
        )
    ax_3d.scatter(final_nodes[:, 0], final_nodes[:, 1], final_nodes[:, 2], c=colors, s=40, zorder=5)
    ax_3d.set_xlim(0, 1)
    ax_3d.set_ylim(0, 1)
    ax_3d.set_zlim(0, 1)
    ax_3d.set_title("3D View\n(Green=Traversable, Red=Non-traversable, Orange=Contour)")
    ax_3d.view_init(elev=25, azim=azim_start)

    ax_2d = fig_final.add_subplot(1, 2, 2)
    ax_2d.scatter(samples[:, 1], samples[:, 2], c="skyblue", s=2, alpha=0.2)
    for i, j in final_pos_edges:
        ax_2d.plot([final_nodes[i, 1], final_nodes[j, 1]], [final_nodes[i, 2], final_nodes[j, 2]],
                   "gray", linewidth=0.3, alpha=0.3)
    ax_2d.scatter(final_nodes[:, 1], final_nodes[:, 2], c=colors, s=40, zorder=5)
    ax_2d.set_xlim(1, 0)
    ax_2d.set_ylim(0, 1)
    ax_2d.set_xlabel("Y (depth)")
    ax_2d.set_ylabel("Z (height)")
    ax_2d.set_aspect("equal")
    ax_2d.set_title("Side View (YZ)")

    n_traversable = int(np.sum(final_traversability))
    n_contour = int(np.sum(final_contour))
    plt.suptitle(
        f"GNG-DT Robot: {len(final_nodes)} nodes, {n_traversable} traversable, {n_contour} contour",
        fontsize=12
    )
    plt.tight_layout()
    plt.savefig(output_png, dpi=150, bbox_inches="tight", facecolor="white")
    print(f"Saved PNG: {output_png}")
    plt.close(fig_final)


def main():
    parser = argparse.ArgumentParser(description="Visualize 3D GNG test results")
    parser.add_argument("input_dir", help="Input directory with CSV files")
    parser.add_argument(
        "--algorithm",
        choices=["gng", "gngu", "gngdt", "gngdt_robot", "aisgng", "aisgng_am", "aisgng_roman"],
        default="gng",
        help="Algorithm type (default: gng)"
    )
    parser.add_argument("--output-gif", help="Output GIF path")
    parser.add_argument("--output-png", help="Output PNG path")

    args = parser.parse_args()

    input_path = Path(args.input_dir)

    # Auto-detect algorithm from metadata if present
    metadata_path = input_path / "metadata.csv"
    if metadata_path.exists():
        metadata = load_metadata(metadata_path)
        algo_name = metadata.get("algorithm", "").lower().replace("-", "_")
        if "robot" in algo_name:
            args.algorithm = "gngdt_robot"
        elif "dt" in algo_name:
            args.algorithm = "gngdt"
        elif "am" in algo_name:
            args.algorithm = "aisgng_am"
        elif "roman" in algo_name:
            args.algorithm = "aisgng_roman"
        elif "ais" in algo_name:
            args.algorithm = "aisgng"
        elif "gngu" in algo_name or "gng_u" in algo_name:
            args.algorithm = "gngu"

    # Set default output paths
    output_gif = args.output_gif or f"{args.algorithm}_floor_wall_growth.gif"
    output_png = args.output_png or f"{args.algorithm}_floor_wall_final.png"

    print(f"Visualizing {args.algorithm} results from {args.input_dir}")
    print(f"Output GIF: {output_gif}")
    print(f"Output PNG: {output_png}")
    print()

    if args.algorithm == "gngdt_robot":
        visualize_gngdt_robot(args.input_dir, output_gif, output_png)
    elif args.algorithm == "gngdt":
        visualize_gngdt(args.input_dir, output_gif, output_png)
    else:
        # Basic GNG visualization (works for GNG, GNG-U, AiS-GNG variants)
        algorithm_names = {
            "gng": "GNG",
            "gngu": "GNG-U",
            "aisgng": "AiS-GNG",
            "aisgng_am": "AiS-GNG-AM",
            "aisgng_roman": "AiS-GNG-RO-MAN",
        }
        visualize_gng(args.input_dir, output_gif, output_png, algorithm_names.get(args.algorithm, args.algorithm.upper()))

    print("\nDone!")


if __name__ == "__main__":
    main()
